package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"errors"
	"strconv"
	"time"

	"github.com/jayk0001/my-go-next-todo/internal/graphql/model"
	"github.com/jayk0001/my-go-next-todo/internal/todo"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.CreateTodoInput) (*model.Todo, error) {
	// Extract user ID from context (set by auth middleware)
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL input to service input
	serviceInput := todo.CreateTodoInput{
		Title:       input.Title,
		Description: input.Description,
	}

	// Call service layer
	todoResult, err := r.TodoService.CreateTodo(ctx, userID, serviceInput)
	if err != nil {
		return nil, err
	}

	// Convert Service result to GraphQL model
	return convertTodoToGraphQL(todoResult), nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, id string, input model.UpdateTodoInput) (*model.Todo, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	todoId, err := strconv.Atoi(id)
	if err != nil {
		return nil, todo.ErrInvalidTodoInput
	}

	// Convert GraphQL input to service input
	serviceInput := todo.UpdateTodoInput{
		Title:       input.Title,
		Description: input.Description,
		Completed:   input.Completed,
	}

	// Call service layer
	todoResult, err := r.TodoService.UpdateTodo(ctx, todoId, userID, serviceInput)
	if err != nil {
		return nil, err
	}

	return convertTodoToGraphQL(todoResult), nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	todoID, err := strconv.Atoi(id)
	if err != nil {
		return false, todo.ErrInvalidTodoInput
	}

	// Call service layer
	err = r.TodoService.DeleteTodo(ctx, todoID, userID)
	if err != nil {
		return false, err
	}

	return true, err
}

// ToggleTodo is the resolver for the toggleTodo field.
func (r *mutationResolver) ToggleTodo(ctx context.Context, id string) (*model.Todo, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	todoID, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}

	// Call service layer
	todoResult, err := r.TodoService.ToggleTodoComplete(ctx, todoID, userID)
	if err != nil {
		return nil, err
	}

	return convertTodoToGraphQL(todoResult), err
}

// BatchUpdateTodos is the resolver for the batchUpdateTodos field.
func (r *mutationResolver) BatchUpdateTodos(ctx context.Context, input model.BatchUpdateInput) ([]*model.Todo, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Convert graphQL todo IDs to integers
	todoIds := make([]int, len(input.TodoIds))
	for i, idStr := range input.TodoIds {
		id, err := strconv.Atoi(idStr)
		if err != nil {
			return nil, todo.ErrInvalidTodoInput
		}
		todoIds[i] = id
	}

	// Convert GraphQL input to service input
	serviceInput := todo.UpdateTodoInput{
		Title:       input.Updates.Title,
		Description: input.Updates.Description,
		Completed:   input.Updates.Completed,
	}

	// Call service layer
	todoResults, err := r.TodoService.BatchUpdateTodos(ctx, userID, todoIds, serviceInput)
	if err != nil {
		return nil, err
	}

	// Convert results to GraphQL models
	var graphQLTodos []*model.Todo
	for _, todoResult := range todoResults {
		graphQLTodos = append(graphQLTodos, convertTodoToGraphQL(todoResult))
	}

	return graphQLTodos, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, filter *model.TodoFilter) (*model.TodoListResponse, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Convert GraphQL filter to service filter
	serviceFilter := todo.TodoFilter{}
	if filter != nil {
		serviceFilter.Completed = filter.Completed
		serviceFilter.Search = filter.Search
		if filter.Limit != nil {
			serviceFilter.Limit = *filter.Limit
		}
		if filter.Offset != nil {
			serviceFilter.Offset = *filter.Offset
		}
	}

	// Call service layer
	result, err := r.TodoService.GetUserTodos(ctx, userID, serviceFilter)
	if err != nil {
		return nil, err
	}

	// Convert results to GraphQL models
	var graphqlTodos []*model.Todo
	for _, todoResult := range result.Todos {
		graphqlTodos = append(graphqlTodos, convertTodoToGraphQL(todoResult))
	}

	return &model.TodoListResponse{
		Todos:   graphqlTodos,
		Total:   result.Total,
		Limit:   result.Limit,
		Offset:  result.Offset,
		HasMore: result.HasMore,
	}, nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string) (*model.Todo, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	todoID, err := strconv.Atoi(id)
	if err != nil {
		return nil, todo.ErrInvalidTodoInput
	}

	// Call service layer
	todoResult, err := r.TodoService.GetTodo(ctx, todoID, userID)
	if err != nil {
		return nil, err
	}

	return convertTodoToGraphQL(todoResult), nil
}

// TodoStats is the resolver for the todoStats field.
func (r *queryResolver) TodoStats(ctx context.Context) (*model.TodoStats, error) {
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Call service layer
	stats, err := r.TodoService.GetUserTodoStats(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &model.TodoStats{
		Total:     stats.Total,
		Completed: stats.Completed,
		Pending:   stats.Pending,
	}, nil
}

// TodoChanged is the resolver for the todoChanged field.
func (r *subscriptionResolver) TodoChanged(ctx context.Context) (<-chan *model.Todo, error) {
	// TODO: Implement real-time subscriptions in future
	// For now, return a simple channel
	ch := make(chan *model.Todo)
	close(ch)
	return ch, nil
}

// TodoStatsChanged is the resolver for the todoStatsChanged field.
func (r *subscriptionResolver) TodoStatsChanged(ctx context.Context) (<-chan *model.TodoStats, error) {
	// TODO: Implement real-time subscriptions in future
	// For now, return a simple channel
	ch := make(chan *model.TodoStats)
	close(ch)
	return ch, nil
}

// Helper function to convert service Todo to graphQL Todo
func convertTodoToGraphQL(t *todo.Todo) *model.Todo {
	return &model.Todo{
		ID:          strconv.Itoa(t.ID),
		Title:       t.Title,
		Description: t.Description,
		Completed:   t.Completed,
		CreatedAt:   t.CreatedAt.Format(time.RFC3339),
		UpdatedAt:   t.UpdatedAt.Format(time.RFC3339),
	}
}

// Helper function to extract user ID from context
func getUserIDFromContext(ctx context.Context) (int, error) {
	// This assumes the auth middleware sets the user ID in context
	// Adjust based on your auth middleware implementation
	userID, ok := ctx.Value("UserID").(int)
	if !ok {
		return 0, errors.New("user not authenticated")
	}

	return userID, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *todoResolver) CreatedAt(ctx context.Context, obj *todo.Todo) (string, error) {
	panic(fmt.Errorf("not implemented: CreatedAt - createdAt"))
}
func (r *todoResolver) UpdatedAt(ctx context.Context, obj *todo.Todo) (string, error) {
	panic(fmt.Errorf("not implemented: UpdatedAt - updatedAt"))
}
func (r *todoResolver) User(ctx context.Context, obj *todo.Todo) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}
func (r *Resolver) Todo() generated.TodoResolver { return &todoResolver{r} }
type todoResolver struct{ *Resolver }
*/
